<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Zellij User Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="configuration.html"><strong aria-hidden="true">2.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="keybindings.html"><strong aria-hidden="true">2.1.</strong> Configuring Keybindings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="keybindings-modes.html"><strong aria-hidden="true">2.1.1.</strong> Modes</a></li><li class="chapter-item expanded "><a href="keybindings-keys.html"><strong aria-hidden="true">2.1.2.</strong> Keys</a></li><li class="chapter-item expanded "><a href="keybindings-actions.html"><strong aria-hidden="true">2.1.3.</strong> Actions</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="layouts.html"><strong aria-hidden="true">3.</strong> Layouts</a></li><li class="chapter-item expanded "><a href="plugins.html"><strong aria-hidden="true">4.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plugin-writing.html"><strong aria-hidden="true">4.1.</strong> Developing a Plugin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plugin-rust.html"><strong aria-hidden="true">4.1.1.</strong> Rust</a></li><li class="chapter-item expanded "><a href="plugin-other.html"><strong aria-hidden="true">4.1.2.</strong> Other Languages</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="compatibility.html"><strong aria-hidden="true">5.</strong> Compatibility</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Zellij User Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This is the documentation for the Zellij terminal workspace.</p>
<ul>
<li>For configuring Zellij, see: <a href="./configuration.html">Configuration</a></li>
<li>For setting up layouts: <a href="./configuration.html">Layouts</a></li>
<li>For developing plugins: <a href="./plugins.html">Plugins</a></li>
</ul>
<h1><a class="header" href="#configuration" id="configuration">Configuration</a></h1>
<p>Zellij will look for a file <code>config.yaml</code> in the default configuration location of your os:</p>
<p><strong>Linux</strong>: <code>/home/alice/.config/zellij</code></p>
<p><strong>Mac</strong>: <code>/Users/Alice/Library/Application Support/com.Zellij-Contributors.zellij</code></p>
<p>To ignore the default config file location:</p>
<pre><code>zellij config --clean
</code></pre>
<p>To pass a config file directly to zellij:</p>
<pre><code>zellij config [FILE]
</code></pre>
<h2><a class="header" href="#current-main" id="current-main">Current Main:</a></h2>
<p>This changed in the current main branch.</p>
<p>To ignore the default config file location:</p>
<pre><code>zellij option --clean
</code></pre>
<p>To pass a config file directly to zellij:</p>
<pre><code>zellij --config [FILE]
</code></pre>
<p>Or use the <code>ZELLIJ_CONFIG</code> environment variable,
in order to pass the location.</p>
<p>The config order is as follows:</p>
<ol>
<li><code>--config</code> flag</li>
<li><code>ZELLIJ_CONFIG</code> variable</li>
<li>default location</li>
</ol>
<h1><a class="header" href="#configuring-keybindings" id="configuring-keybindings">Configuring Keybindings</a></h1>
<p>Zellij comes with a default set of keybindings that try to fit as many different users and use cases while trying to maximize comfort for everyone.</p>
<p>It is possible to add to these defaults or even override them with an external configuration. For more information about the file, see <a href="./configuration.html">Configuration</a>.</p>
<p>The structure of the <code>keybinds</code> section of the file is as follows:</p>
<pre><code>keybinds:
    normal:
        - action: []
          key: []
</code></pre>
<p>Under the main <code>keybinds</code> section one can list the new bindings they'd like to add grouped under the different <a href="keybindings-modes.html">Modes</a> (<code>normal</code> in this example).
The <a href="./keybindings-actions.html"><code>action</code></a> is a sequence of one or more instructions sent to Zellij through this keybinding. The <a href="keybindings-keys.html"><code>key</code></a> is a list of one or more keys, any one of them alone would trigger the sequence of actions.</p>
<p>For example:</p>
<pre><code>keybinds:
    normal:
        - action: [ NewTab, GoToTab: 1,]
          key: [ Char: 'c',]
</code></pre>
<p>Will create a new tab and then switch to tab number 1 on pressing the
<code>c</code> key.
Whereas:</p>
<pre><code>keybinds:
    normal:
        - action: [ NewTab,]
          key: [ Char: 'c', Char: 'd',]
</code></pre>
<p>Will create a new tab on pressing either the <code>c</code> or the <code>d</code> key.</p>
<h2><a class="header" href="#to-override-the-default-keybindings" id="to-override-the-default-keybindings">To override the default Keybindings</a></h2>
<pre><code>keybinds:
    unbind: true
</code></pre>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>This configuration can be used to configure Zellij's default keybindings: <a href="https://github.com/zellij-org/zellij/blob/main/example/default.yaml">default.yaml</a></p>
<h1><a class="header" href="#modes" id="modes">Modes</a></h1>
<p>The Zellij <a href="./keybindings.html">keybindings</a> are grouped into different <code>modes</code>, which are a logical separation meant to reduce the mental overhead and allow to duplicate shortcuts in different situations.</p>
<h2><a class="header" href="#normal" id="normal">normal</a></h2>
<p>This is the default mode Zellij starts with. By default it provides the ability to switch to different modes, as well as some quick navigation shortcuts.</p>
<h2><a class="header" href="#locked" id="locked">locked</a></h2>
<p>This mode &quot;locks&quot; the interface, disabling all keybindings except one that would switch to &quot;normal&quot; mode (<code>ctrl-g</code> by default).
It is intended to give users a workaround in case one of the default keybindings overrides something they use in their terminal. (eg. <code>ctrl-r</code> for reverse history search in bash).</p>
<h2><a class="header" href="#pane" id="pane">pane</a></h2>
<p>This mode includes instructions that manipulate the different panes. Eg. adding new panes, closing panes and moving the focused pane.</p>
<h2><a class="header" href="#tab" id="tab">tab</a></h2>
<p>This mode includes instructions that manipulate the different tabs. Eg. adding new tabs, closing tabs and moving the active tab.</p>
<h2><a class="header" href="#resize" id="resize">resize</a></h2>
<p>This mode allows the resizing of the focused pane.</p>
<h2><a class="header" href="#scroll" id="scroll">scroll</a></h2>
<p>This mode allows scrolling up/down within the focused pane.</p>
<h1><a class="header" href="#keys" id="keys">Keys</a></h1>
<p>These are the possible keys and key combinations one can set in the <a href="./keybindings.html">Keybindings configuration</a>.
For more information, please see: <a href="https://docs.rs/termion/1.5.6/termion/event/enum.Key.html">https://docs.rs/termion/1.5.6/termion/event/enum.Key.html</a></p>
<h2><a class="header" href="#char-character" id="char-character"><code>Char: &lt;character&gt;</code></a></h2>
<p>A single character with no modifier, eg. <code>Char: f</code></p>
<h2><a class="header" href="#alt-character" id="alt-character"><code>Alt: &lt;character&gt;</code></a></h2>
<p>A single character preceded by the <code>Alt</code> modifier, eg. <code>Alt: f</code>.</p>
<h2><a class="header" href="#ctrl-character" id="ctrl-character"><code>Ctrl: &lt;character&gt;</code></a></h2>
<p>A single character preceded by the <code>Ctrl</code> modifier, eg. <code>Ctrl: f</code>.</p>
<h2><a class="header" href="#f-1-12" id="f-1-12"><code>F: &lt;1-12&gt;</code></a></h2>
<p>One of the <code>F</code> characters (usually at the top of the keyboard). eg. <code>F: 11</code></p>
<h2><a class="header" href="#backspace" id="backspace"><code>Backspace</code></a></h2>
<p>The Backspace key.</p>
<h2><a class="header" href="#left--right--up--down" id="left--right--up--down"><code>Left</code> / <code>Right</code> / <code>Up</code> / <code>Down</code></a></h2>
<p>The arrow keys on the keyboard.</p>
<h2><a class="header" href="#home" id="home"><code>Home</code></a></h2>
<p>The home key.</p>
<h2><a class="header" href="#end" id="end"><code>End</code></a></h2>
<p>The End key.</p>
<h2><a class="header" href="#pageup--pagedown" id="pageup--pagedown"><code>PageUp</code> / <code>PageDown</code></a></h2>
<p>The PageUp or PageDown keys.</p>
<h2><a class="header" href="#backtab" id="backtab"><code>BackTab</code></a></h2>
<p>The backward Tab key.</p>
<h2><a class="header" href="#delete" id="delete"><code>Delete</code></a></h2>
<p>The delete key.</p>
<h2><a class="header" href="#insert" id="insert"><code>Insert</code></a></h2>
<p>The insert key.</p>
<h2><a class="header" href="#esc" id="esc"><code>Esc</code></a></h2>
<p>The Esc key.</p>
<h1><a class="header" href="#actions" id="actions">Actions</a></h1>
<p>These are the actions that can be assigned to key sequences when <a href="./keybindings.html">configuring keybindings</a>.</p>
<h2><a class="header" href="#quit" id="quit"><code>Quit</code></a></h2>
<p>Quit Zellij.</p>
<h2><a class="header" href="#switchtomode-inputmode" id="switchtomode-inputmode"><code>SwitchToMode: &lt;InputMode&gt;</code></a></h2>
<p>Switch to the specified <a href="./keybindings-modes.html">input mode</a>.
The mode should be capitalized, eg. <code>SwitchToMode: Normal</code>.</p>
<p>Note that there's a &quot;hidden&quot; mode called <code>RenameTab</code> which can be used in order to trigger the renaming of a tab.</p>
<h2><a class="header" href="#resize-direction" id="resize-direction"><code>Resize: &lt;Direction&gt;</code></a></h2>
<p>Resize focused pane in specified direction.
Direction should be one of <code>Left</code>, <code>Right</code>, <code>Up</code> or <code>Down</code>.</p>
<p>eg. <code>Resize: Down</code></p>
<h2><a class="header" href="#focusnextpane" id="focusnextpane"><code>FocusNextPane</code></a></h2>
<p>Switch focus to next pane to the right or below if on screen edge.</p>
<h2><a class="header" href="#focuspreviouspane" id="focuspreviouspane"><code>FocusPreviousPane</code></a></h2>
<p>Switch focus to next pane to the left or above if on screen edge.</p>
<h2><a class="header" href="#switchfocus" id="switchfocus"><code>SwitchFocus</code></a></h2>
<p>Switch focus to pane with the next ID (this is mostly left around for legacy support, <code>FocusNextPane</code> or <code>FocusPreviousPane</code> should be preferred).</p>
<h2><a class="header" href="#movefocus-direction" id="movefocus-direction"><code>MoveFocus: &lt;Direction&gt;</code></a></h2>
<p>Move focus to the pane with the greatest overlap with the current pane in the specified direction. 
Direction should be one of <code>Left</code>, <code>Right</code>, <code>Up</code> or <code>Down</code>.</p>
<p>eg. <code>MoveFocus: Left</code></p>
<h2><a class="header" href="#scrollup" id="scrollup"><code>ScrollUp</code></a></h2>
<p>Scroll up 1 line inside the focused pane.</p>
<h2><a class="header" href="#scrolldown" id="scrolldown"><code>ScrollDown</code></a></h2>
<p>Scroll down 1 line inside the focused pane.</p>
<h2><a class="header" href="#togglefocusfullscreen" id="togglefocusfullscreen"><code>ToggleFocusFullscreen</code></a></h2>
<p>Toggle between fullscreen focus pane and normal layout.</p>
<h2><a class="header" href="#newpane-direction" id="newpane-direction"><code>NewPane: &lt;Direction&gt;</code></a></h2>
<p>Open a new pane in the specified direction (relative to focus).
If no direction is specified, will try to use the biggest available space.
Direction should be one of <code>Left</code>, <code>Right</code>, <code>Up</code> or <code>Down</code>.
Specifying no direction should be done by introducing a space character (this is a bug and should be fixed).</p>
<p>eg. <code>NewPane: Left</code> or <code>NewPane: </code></p>
<h2><a class="header" href="#closefocus" id="closefocus"><code>CloseFocus</code></a></h2>
<p>Close the focused pane.</p>
<h2><a class="header" href="#newtab" id="newtab"><code>NewTab</code></a></h2>
<p>Create a new tab.</p>
<h2><a class="header" href="#gotonexttab" id="gotonexttab"><code>GoToNextTab</code></a></h2>
<p>Go to the next tab.</p>
<h2><a class="header" href="#gotoprevioustab" id="gotoprevioustab"><code>GoToPreviousTab</code></a></h2>
<p>Go to the previous tab.</p>
<h2><a class="header" href="#closetab" id="closetab"><code>CloseTab</code></a></h2>
<p>Close the current tab.</p>
<h2><a class="header" href="#gototab-index" id="gototab-index"><code>GoToTab: &lt;index&gt;</code></a></h2>
<p>Go to the tab of the specified index.</p>
<h1><a class="header" href="#layouts" id="layouts">Layouts</a></h1>
<p>Layouts are yaml configuration files which Zellij can load on startup. These files can describe a layout of terminal panes and plugins that Zellij will create when it loads.
To load a layout with Zellij:</p>
<pre><code>zellij --layout /path/to/your/layout_file.yaml
</code></pre>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<p>This file:</p>
<pre><code class="language-yaml">---
direction: Vertical
parts:
  - direction: Horizontal
    split_size:
      Percent: 50
    parts:
      - direction: Vertical
        split_size:
          Percent: 50
      - direction: Vertical
        split_size:
          Percent: 50
  - direction: Horizontal
    split_size:
      Percent: 50
</code></pre>
<p>Will instruct Zellij to create this layout:</p>
<pre><code>┌─────┬─────┐
│     │     │
├─────┤     │
│     │     │
└─────┴─────┘
</code></pre>
<h2><a class="header" href="#creating-a-layout-file" id="creating-a-layout-file">Creating a layout file</a></h2>
<p>A layout file is a nested tree structure. Each node describes either a pane, or a space in which its parts (children) will be created.</p>
<p>Each node has the following fields:</p>
<h3><a class="header" href="#direction-horizontal--vertical" id="direction-horizontal--vertical"><code>direction: Horizontal / Vertical</code></a></h3>
<p>If the node has children, they will be created as splits in this direction.</p>
<h3><a class="header" href="#split_size-percent-1-100--fixed-linescolumns" id="split_size-percent-1-100--fixed-linescolumns"><code>split_size: Percent: &lt;1-100&gt; / Fixed: &lt;lines/columns&gt;</code></a></h3>
<p>This indicates either a percentage of the node's parent's space or a fixed size of columns/rows from its parent's space.</p>
<h3><a class="header" href="#plugin-pathtopluginwasm" id="plugin-pathtopluginwasm"><code>plugin: /path/to/plugin.wasm</code></a></h3>
<p>This is an optional path to a compiled Zellij plugin. If indicated, instead of loading a terminal, this plugin will be loaded. For more information, please see the plugin documentation of this guide.</p>
<h2><a class="header" href="#further-examples" id="further-examples">Further examples</a></h2>
<p>Please see the default layouts that come with Zellij: <a href="https://github.com/zellij-org/zellij/tree/main/assets/layouts">layouts</a></p>
<h1><a class="header" href="#plugins" id="plugins">Plugins</a></h1>
<p>One feature that makes Zellij unique is its <a href="https://webassembly.org/">WebAssembly</a> plugin system. This allows plugin developers to write their plugin in any language that can run on <a href="https://wasi.dev/">WASI</a>! Rust offers first-class <a href="https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-tutorial.md#from-rust">support for WASI</a>, but other languages like <a href="https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-tutorial.md#from-c">C/C++</a>, <a href="https://wasmbyexample.dev/examples/wasi-hello-world/wasi-hello-world.assemblyscript.en-us.html">AssemblyScript</a>, even <a href="https://wapm.io/package/rustpython">Python</a> should be supported.</p>
<p><strong>Disclaimer: The API for plugins is very much a work in progress. Don't be shy to request new features on our <a href="https://github.com/zellij-org/zellij/issues/280">tracking issue</a>!</strong></p>
<h1><a class="header" href="#developing-a-plugin" id="developing-a-plugin">Developing a Plugin</a></h1>
<p>Currently we have a complete guide for developing plugins in <a href="./plugin-rust.html">Rust</a> and plan to add more guides for other languages in the future. If you are feeling particularly brave, you can try to write plugins in another language today! The <a href="./plugin-other.html">Other Languages</a> section will get you started.</p>
<h1><a class="header" href="#writing-a-plugin-in-rust" id="writing-a-plugin-in-rust">Writing a Plugin in Rust</a></h1>
<p>Writing a Zellij plugin in Rust is incredibly easy thanks to Rust's first-class support for WebAssembly and the simple <a href="https://docs.rs/zellij-tile/"><code>zellij-tile</code></a> scaffolding library. This guide will walk through implementing the <a href="https://github.com/zellij-org/rust-plugin-example"><code>rust-plugin-example</code></a>, a simple event logger that records mode-changes within Zellij.</p>
<h2><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h2>
<h3><a class="header" href="#installing-rust--zellij" id="installing-rust--zellij">Installing Rust &amp; Zellij</a></h3>
<p>First things first, to develop a plugin in Rust, you'll need Rust installed! The easiest way to do this is by using <a href="https://rustup.rs/">rustup</a>.</p>
<p>Once you have Rust and Cargo installed, getting the latest version of Zellij is as easy as running:</p>
<pre><code>cargo install zellij
</code></pre>
<p>You'll also want to add the installed binary to your path!</p>
<h3><a class="header" href="#cloning-the-template-repository" id="cloning-the-template-repository">Cloning The Template Repository</a></h3>
<p>To streamline the development experience, we provide a <a href="https://github.com/zellij-org/rust-plugin-template">template repository</a> that contains everything you need to get started quickly!</p>
<p>You can use a tool called <a href="https://github.com/cargo-generate/cargo-generate"><code>cargo-generate</code></a> to fill in a couple of the gaps automatically:</p>
<pre><code class="language-sh"># First install `cargo-generate`
cargo install cargo-generate
# Then clone the rust-plugin template
cargo generate --git https://github.com/zellij-org/rust-plugin-template.git --name mode-logger
cd mode-logger
</code></pre>
<h2><a class="header" href="#the-basic-structure-of-a-rust-plugin" id="the-basic-structure-of-a-rust-plugin">The Basic Structure of a Rust Plugin</a></h2>
<p>After cloning the template repository, you should have a directory that looks a little bit like this: </p>
<pre><code>.
├── .cargo
│   └── config.toml
├── Cargo.toml
├── plugin.yaml
├── README.md
└── src
    └── main.rs
</code></pre>
<h3><a class="header" href="#cargoconfigtoml" id="cargoconfigtoml"><code>.cargo/config.toml</code></a></h3>
<pre><code class="language-toml">[build]
target = &quot;wasm32-wasi&quot;
</code></pre>
<p>This file specifies a default target for our project. In this case, the correct WASI target is <code>wasm32-wasi</code>.</p>
<h3><a class="header" href="#cargotoml" id="cargotoml"><code>Cargo.toml</code></a></h3>
<pre><code class="language-toml">[package]
name = &quot;mode-logger&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Brooks J Rady &lt;b.j.rady@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
zellij-tile = &quot;1.0.0&quot;
</code></pre>
<p>This is a quite standard package file that <code>cargo-generate</code> has partially filled in for us. Note the dependency on <code>zellij-tile</code> which provides some helpful functionality for avoiding boilerplate and writing <code>unsafe</code> code.</p>
<h3><a class="header" href="#pluginyaml" id="pluginyaml"><code>plugin.yaml</code></a></h3>
<pre><code class="language-yaml">---
direction: Horizontal
parts:
  - direction: Vertical
    split_size:
      Fixed: 1
    plugin: tab-bar
  - direction: Vertical
    plugin: target/wasm32-wasi/debug/mode-logger.wasm
  - direction: Vertical
    split_size:
      Fixed: 2
    plugin: status-bar
</code></pre>
<p>This is a Zellij <a href="./layouts.html">Layout</a> that loads a mostly default instance of Zellij, but with the middle terminal pane replaced by the plugin being developed. The <code>plugin: target/wasm32-wasi/debug/mode-logger.wasm</code> line should point Zellij to the development version of our plugin.</p>
<p>There will likely be a better way of loading plugins in the future, but custom Layouts are currently the only way to do so.</p>
<h3><a class="header" href="#srcmainrs" id="srcmainrs"><code>src/main.rs</code></a></h3>
<pre><code class="language-rs">use zellij_tile::prelude::*;

#[derive(Default)]
struct State;

register_plugin!(State);

impl ZellijPlugin for State {
    fn load(&amp;mut self) {}

    fn update(&amp;mut self, event: Event) {}

    fn render(&amp;mut self, rows: usize, cols: usize) {}
}
</code></pre>
<p>When using the <code>zellij-tile</code> library, plugins are written as Structs that implement the <code>ZellijPlugin</code> trait. The magic line here is <code>register_plugin!(State)</code>, which wraps up the <code>State</code> struct in a way that neatly exposes its <code>ZellijPlugin</code> implementation for Zellij to find.</p>
<p>Note that <code>load()</code>, <code>update()</code>, and <code>render()</code> have default implementations, so you only need to define the callbacks used by your plugin.</p>
<h2><a class="header" href="#hello-zellij" id="hello-zellij">Hello, Zellij!</a></h2>
<p>Let's tweak our <code>main.rs</code> a little to say hello!</p>
<pre><code class="language-rs">use zellij_tile::prelude::*;

#[derive(Default)]
struct State;

register_plugin!(State);

impl ZellijPlugin for State {
    fn load(&amp;mut self) {}

    fn update(&amp;mut self, event: Event) {}

    fn render(&amp;mut self, rows: usize, cols: usize) {
        println!(&quot;Hello, Zellij!&quot;);
    }
}
</code></pre>
<p>It really is as simple as that! Anything printed to stdout by the <code>render()</code> method will be automatically drawn to the screen in the pane where the plugin is active.</p>
<p>Let's build our plugin and test things out:</p>
<pre><code class="language-sh">cargo build
zellij -l plugin.yaml
</code></pre>
<p><img src="img/rust-plugin-1.png" alt="Our Plugin" /></p>
<h2><a class="header" href="#implementing-the-event-logger" id="implementing-the-event-logger">Implementing the Event Logger</a></h2>
<p>That was pretty easy, so let's try to do something a bit more interesting! Let's subscribe to some <code>Event</code>s by adding the following code to <code>load()</code>:</p>
<pre><code class="language-rs">fn load(&amp;mut self) {
    subscribe(&amp;[EventType::ModeUpdate]);
}
</code></pre>
<p>Code in <code>load()</code> is called once the first time your plugin is loaded. Aside from that, it's nothing special. Anything that you can do in the <code>load()</code> method should be possible from within the <code>update()</code> and <code>render()</code> methods as well.</p>
<p>The <code>subscribe()</code> function is part of <code>zellij-tile::prelude</code> and sends a message to Zellij asking to be notified when certain <code>Event</code>s occur. In this case, we're subscribing to <code>ModeUpdate</code> events. The <a href="https://docs.rs/zellij-tile/1.0.0/zellij_tile/data/enum.Event.html">documentation for <code>Event</code></a> tells us that a <code>ModeUpdate</code> contains the <code>ModeInfo</code> struct, which stores the current mode as well as some additional information.</p>
<p>To actually handle these events, we'll need to add some code to our <code>update()</code> method:</p>
<pre><code class="language-rs">fn update(&amp;mut self, event: Event) {
    if let Event::ModeUpdate(mode_info) = event {
        dbg!(mode_info.mode);
    }
}
</code></pre>
<p>Here we are checking for <code>ModeUpdate</code>s and destructuring them to get the current mode. Currently, the <code>dbg!()</code> macro is being used to dump this information to stderr. If we want to actually see this debug info, we'll need to run our plugin slightly differently:</p>
<pre><code class="language-sh">cargo build
# The 2&gt; redirects stderr to dbg.log
zellij -l plugin.yaml 2&gt; dbg.log
</code></pre>
<p>Do some faffing about in Zellij, changing modes a couple of times, then take a look at <code>dbg.log</code>:</p>
<pre><code>[src/main.rs:15] mode_info.mode = Normal
[src/main.rs:15] mode_info.mode = Pane
[src/main.rs:15] mode_info.mode = Tab
[src/main.rs:15] mode_info.mode = Resize
[src/main.rs:15] mode_info.mode = Scroll
[src/main.rs:15] mode_info.mode = Locked
[src/main.rs:15] mode_info.mode = Normal
</code></pre>
<p>Excellent! It looks like our plugin is receiving mode updates! If you'd like to see these sorts of logs live, try opening a second terminal and running <code>tail -f dbg.log</code>.</p>
<p>The next thing to do is properly store a log of events and print them to the screen. Let's start by tweaking our <code>State</code> struct:</p>
<pre><code class="language-rs">use std::collections::VecDeque;

#[derive(Default)]
struct State {
    log: VecDeque&lt;String&gt;,
}
</code></pre>
<p>We've gone with a <code>VecDeque</code> so that we can efficiently push <code>String</code>s to the <em>front</em> of <code>log</code> and so we can show off how easy it is to use standard library components from within a plugin.</p>
<p>Let's change the <code>update()</code> method again to grow our log:</p>
<pre><code class="language-rs">fn update(&amp;mut self, event: Event) {
    if let Event::ModeUpdate(mode_info) = event {
        let mode = format!(&quot;{:?}&quot;, mode_info.mode);
        self.log.push_front(mode);
    }
}
</code></pre>
<p>Recall that the <code>{:?}</code> format specifier simply debug-prints a value and that <code>log.push_front(mode)</code> adds a mode <code>String</code> to the front of our log messages.</p>
<p>Finally, let's update <code>render()</code> to print out all of our log messages:</p>
<pre><code class="language-rs">fn render(&amp;mut self, rows: usize, cols: usize) {
    for mode in &amp;self.log {
        println!(&quot;Mode: {}&quot;, mode);
    }
}
</code></pre>
<p>Let's give things a run with <code>cargo build &amp;&amp; zellij -l plugin.yaml</code> and test it out!</p>
<p><img src="img/rust-plugin-2.png" alt="Our Plugin" /></p>
<p>Excellent! You should notice that, as you cycle through different modes in Zellij, that those updates are being logged on-screen.</p>
<p>This is a good start, but no logger is complete without storing timestamps! Let's import the <code>chrono</code> crate for working with time. First we'll need to add it to our <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;mode-logger&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Brooks J Rady &lt;b.j.rady@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
zellij-tile = &quot;1.0.0&quot;
chrono = &quot;0.4&quot;
</code></pre>
<p>Quite a few Rust libraries can compile to WebAssembly without any issue – this is one of them! Let's import it and update <code>State</code> to store timestamps:</p>
<pre><code class="language-rs">use chrono::{DateTime,Local};

#[derive(Default)]
struct State {
    log: VecDeque&lt;(String, DateTime&lt;Local&gt;)&gt;,
}
</code></pre>
<p>Next we'll need to actually store these timestamps in <code>update()</code>:</p>
<pre><code class="language-rs">fn update(&amp;mut self, event: Event) {
    if let Event::ModeUpdate(mode_info) = event {
        let mode = format!(&quot;{:?}&quot;, mode_info.mode);
        // Local::now() gets the current time and date
        self.log.push_front((mode, Local::now()));
    }
}
</code></pre>
<p>Finally, we can <code>render()</code> the timestamps to the screen:</p>
<pre><code class="language-rs">fn render(&amp;mut self, rows: usize, cols: usize) {
    for (mode, time) in &amp;self.log {
        println!(&quot;Mode: {} ({})&quot;, mode, time.format(&quot;%T&quot;));
    }
}
</code></pre>
<p>The different options for <code>time.format()</code> can be found in the <a href="https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html"><code>chrono::format::strftime</code></a> module; <code>%T</code> shows the time in <code>HH:MM:SS</code> format.</p>
<p>Finally, let's test this out!</p>
<p><img src="img/rust-plugin-3.png" alt="Our Plugin" /></p>
<p>It looks like getting the time is working perfectly! Unfortunately, because our different mode names are different lengths, it looks a bit messy at the moment. Luckily, every time that <code>render()</code> is called, it passes the size of plugin pane. Let's use the <code>cols</code> value to right-align the timestamp:</p>
<pre><code class="language-rs">fn render(&amp;mut self, _rows: usize, cols: usize) {
    for (mode, time) in &amp;self.log {
        let mode = format!(&quot;Mode: {}&quot;, mode);
        let time = time.format(&quot;%T&quot;).to_string();
        let padding = &quot; &quot;.repeat(cols - mode.len() - time.len());
        println!(&quot;{}{}{}&quot;, mode, padding, time);
    }
}
</code></pre>
<p>By separately storing the left-aligned mode <code>String</code> and the right-aligned timestamp, we can calculate (using <code>cols</code>) exactly how much padding we need to fill the screen. Once we've done that, it's just a matter of printing the left half, the padding, then the right half.</p>
<p>If we run this code, we now get the much nicer:</p>
<p><img src="img/rust-plugin-4.png" alt="Our Plugin" /></p>
<p>Try resizing your terminal window or the plugin pane and watch how things stay properly justified!</p>
<p>As a final step, let's add a couple of commands that allow the user to clear their history or save their log to a file. To do this, we'll need our plugin to receive <code>KeyPress</code> events:</p>
<pre><code class="language-rs">fn load(&amp;mut self) {
    subscribe(&amp;[EventType::ModeUpdate, EventType::KeyPress]);
}
</code></pre>
<p>Now we can expand <code>update()</code> to handle <code>ModeUpdate</code> and <code>KeyPress</code> events. Let's make <code>Ctrl-L</code> the command for clearing the logs:</p>
<pre><code class="language-rs">fn update(&amp;mut self, event: Event) {
    match event {
        Event::ModeUpdate(mode_info) =&gt; {
            let mode = format!(&quot;{:?}&quot;, mode_info.mode);
            self.log.push_front((mode, Local::now()));
        }
        Event::KeyPress(Key::Ctrl('l')) =&gt; self.log.clear(),
        _ =&gt; (),
    }
}
</code></pre>
<p>When matching against <code>KeyPress</code> events, you might find it helpful to explore the <a href="https://docs.rs/zellij-tile/1.0.0/zellij_tile/data/enum.Key.html">zellij_tile::Key</a> enum.</p>
<p>Also note that we need the catch-all case <code>_ =&gt; ()</code> because, even though we've only subscribed to the <code>ModeUpdate</code> and <code>KeyPress</code> events, the Rust compiler on its own can't guarantee that only those events will be passed to <code>update()</code>.</p>
<p>Let's try running this, changing modes a couple of times, then pressing <code>Ctrl-L</code>:</p>
<p><img src="img/rust-plugin-5.png" alt="Our Plugin" /></p>
<p>Incredibly blank! Nicely done!</p>
<p>As one final feature, we'll dump a log of the captured events to <code>mode-log.txt</code> when <code>Ctrl-W</code> is pressed:</p>
<pre><code class="language-rs">use std::{fs::File, io::Write};

// ... snip ...

fn update(&amp;mut self, event: Event) {
    match event {
        Event::ModeUpdate(mode_info) =&gt; {
            let mode = format!(&quot;{:?}&quot;, mode_info.mode);
            self.log.push_front((mode, Local::now()));
        }
        Event::KeyPress(Key::Ctrl('l')) =&gt; self.log.clear(),
        Event::KeyPress(Key::Ctrl('w')) =&gt; {
            if let Ok(mut f) = File::create(&quot;mode-log.txt&quot;) {
                for (mode, time) in self.log.iter().rev() {
                    writeln!(f, &quot;{}: Entered {} Mode&quot;, time.format(&quot;%c&quot;), mode).unwrap();
                }
            }
        }
        _ =&gt; (),
    }
}
</code></pre>
<p>A couple of new things here, but all of them are vanilla Rust – nothing changes when writing a plugin! <code>File::create(&quot;mode-log.txt&quot;)</code> is just normal code for creating a file named <code>mode-log.txt</code> in the current directory. After the file is created, we're again looping through all of the log events and writing them out (but this time to a file!). The format of the log file is also a bit different from the log we show on-screen. First of all, we're writing things to the log file in <em>chronological</em> order (that's why we're reversing our log with <code>self.log.iter().rev()</code>), and we've also changed to a more verbose timestamp. The <code>%c</code> should look something like this: <code>Tue Apr 20 10:21:02 2021</code>.</p>
<p>Let's run Zellij again, change some modes, then press <code>Ctrl-W</code>:</p>
<p><img src="img/rust-plugin-6.png" alt="Our Plugin" /></p>
<p>We can then look at <code>mode-log.txt</code>, which should look something like this:</p>
<pre><code>Tue Apr 20 10:20:40 2021: Entered Normal Mode
Tue Apr 20 10:20:46 2021: Entered Pane Mode
Tue Apr 20 10:20:50 2021: Entered Tab Mode
Tue Apr 20 10:20:53 2021: Entered Resize Mode
Tue Apr 20 10:20:57 2021: Entered Scroll Mode
Tue Apr 20 10:21:00 2021: Entered Locked Mode
Tue Apr 20 10:21:02 2021: Entered Normal Mode
</code></pre>
<p>And that's all, folks! The full code for this example can be found in the <a href="https://github.com/zellij-org/rust-plugin-example/blob/main/src/main.rs"><code>rust-plugin-example</code></a> repository.</p>
<h2><a class="header" href="#further-steps" id="further-steps">Further Steps</a></h2>
<p>There are a <em>lot</em> of ways that this plugin could be improved! Here are a couple of the things that you might want to try implementing if you're looking for the extra practice:</p>
<ul>
<li><strong>Support for scrolling ::</strong> you'll need to use <code>rows</code> and save a cursor position in <code>State</code></li>
<li><strong>Make it pretty ::</strong> our default plugins use the <a href="https://crates.io/crates/colored"><code>colored</code></a> crate for fancy formatting</li>
<li><strong>Make it more stable ::</strong> if you make the logger pane too small, the plugin will crash!</li>
<li><strong>Add a help bar ::</strong> there is currently no UI telling the user about the clear and save features</li>
</ul>
<p>Have fun, and don't hesitate to get in touch if you find any bugs or would like some guidance :)</p>
<h1><a class="header" href="#writing-a-plugin-in-another-language" id="writing-a-plugin-in-another-language">Writing a Plugin in Another Language</a></h1>
<p>This page is very much a work in progress! If you're familiar with WASM and Rust, then understanding the <a href="https://github.com/zellij-org/zellij/tree/main/zellij-tile"><code>zellij-tile</code></a> library is a great place to start.</p>
<p>In short, Zellij expects your WASI module to export three functions:</p>
<ul>
<li><code>main()</code> :: called once on plugin load</li>
<li><code>update()</code> :: called after event subscriptions are triggered</li>
<li><code>render(i32, i32)</code> :: called when the plugin needs to be rendered</li>
</ul>
<p>The <code>render(i32, i32)</code> function is passed the size of the plugin pane, first the rows, then the columns – e.g. <code>render(rows, cols)</code>.</p>
<p>Complex types are sent over stdin as JSON objects. Before <code>update()</code> is called, Zellij writes an event to the plugin's stdin that can be read back in the <code>update()</code> function.</p>
<p>Host functions, for communicating with Zellij, are best documented by the <code>extern</code> section of <a href="https://github.com/zellij-org/zellij/blob/main/zellij-tile/src/shim.rs"><code>zellij-tile::shim</code></a> and are found in a WASM module named <code>zellij</code>.</p>
<p><strong>Help Add More Language Guides!</strong> If you'd like to contribute, either drop us a line on <a href="https://discord.gg/CrUAFH3">Discord</a> or open a PR improving <a href="https://github.com/zellij-org/zellij-org.github.io/tree/main/docs">these docs</a>!</p>
<h1><a class="header" href="#compatibility--known-issues" id="compatibility--known-issues">Compatibility &amp; Known Issues</a></h1>
<h2><a class="header" href="#the-status-bar-fonts-dont-render-correctly" id="the-status-bar-fonts-dont-render-correctly">The status bar fonts don't render correctly:</a></h2>
<p>This most likely is caused by a missing character in the font.</p>
<p>Fonts from <a href="https://github.com/ryanoasis/nerd-fonts">nerdfonts</a> can fix this problem.</p>
<p>Some Options:</p>
<table><thead><tr><th>Package Manager</th><th align="center">Name</th></tr></thead><tbody>
<tr><td>apt</td><td align="center">fonts-powerline</td></tr>
<tr><td>nix</td><td align="center">nerdfonts</td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
