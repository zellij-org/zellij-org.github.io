<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust - Zellij User Guide</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="integration.html"><strong aria-hidden="true">1.3.</strong> Integration</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">1.4.</strong> FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">2.</strong> Commands</a></li><li class="chapter-item expanded "><a href="configuration.html"><strong aria-hidden="true">3.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="options.html"><strong aria-hidden="true">3.1.</strong> Options</a></li><li class="chapter-item expanded "><a href="keybindings.html"><strong aria-hidden="true">3.2.</strong> Configuring Keybindings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="keybindings-modes.html"><strong aria-hidden="true">3.2.1.</strong> Modes</a></li><li class="chapter-item expanded "><a href="keybindings-keys.html"><strong aria-hidden="true">3.2.2.</strong> Keys</a></li><li class="chapter-item expanded "><a href="keybindings-examples.html"><strong aria-hidden="true">3.2.3.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="themes.html"><strong aria-hidden="true">3.3.</strong> Themes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="theme-gallery.html"><strong aria-hidden="true">3.3.1.</strong> Theme Gallery</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="actions.html"><strong aria-hidden="true">4.</strong> Actions</a></li><li class="chapter-item expanded "><a href="layouts.html"><strong aria-hidden="true">5.</strong> Layouts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layouts-templates.html"><strong aria-hidden="true">5.1.</strong> Templates</a></li></ol></li><li class="chapter-item expanded "><a href="plugins.html"><strong aria-hidden="true">6.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plugin-overview.html"><strong aria-hidden="true">6.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="plugin-writing.html"><strong aria-hidden="true">6.2.</strong> Developing a Plugin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plugin-rust.html" class="active"><strong aria-hidden="true">6.2.1.</strong> Rust</a></li><li class="chapter-item expanded "><a href="plugin-zig.html"><strong aria-hidden="true">6.2.2.</strong> Zig</a></li><li class="chapter-item expanded "><a href="plugin-other.html"><strong aria-hidden="true">6.2.3.</strong> Other Languages</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="compatibility.html"><strong aria-hidden="true">7.</strong> Compatibility</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Zellij User Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="writing-a-plugin-in-rust"><a class="header" href="#writing-a-plugin-in-rust">Writing a Plugin in Rust</a></h1>
<h3 id="please-see-the-up-to-date-documentation-for-the-most-recent-features"><a class="header" href="#please-see-the-up-to-date-documentation-for-the-most-recent-features"><strong>Please see the <a href="/documentation">up-to-date documentation</a> for the most recent features.</strong></a></h3>
<p>Writing a Zellij plugin in Rust is incredibly easy thanks to Rust's first-class support for WebAssembly and the simple <a href="https://docs.rs/zellij-tile/"><code>zellij-tile</code></a> scaffolding library. This guide will walk through implementing the <a href="https://github.com/zellij-org/rust-plugin-example"><code>rust-plugin-example</code></a>, a simple event logger that records mode-changes within Zellij.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<h3 id="installing-rust--zellij"><a class="header" href="#installing-rust--zellij">Installing Rust &amp; Zellij</a></h3>
<p>First things first, to develop a plugin in Rust, you'll need Rust installed! The easiest way to do this is by using <a href="https://rustup.rs/">rustup</a>.</p>
<p>Once you have Rust and Cargo installed, getting the latest version of Zellij is as easy as running:</p>
<pre><code>cargo install zellij
</code></pre>
<p>You'll also want to add the installed binary to your path!</p>
<h3 id="cloning-the-template-repository"><a class="header" href="#cloning-the-template-repository">Cloning The Template Repository</a></h3>
<p>To streamline the development experience, we provide a <a href="https://github.com/zellij-org/rust-plugin-template">template repository</a> that contains everything you need to get started quickly!</p>
<p>You can use a tool called <a href="https://github.com/cargo-generate/cargo-generate"><code>cargo-generate</code></a> to fill in a couple of the gaps automatically:</p>
<pre><code class="language-sh"># First install `cargo-generate`
cargo install cargo-generate
# Then clone the rust-plugin template
cargo generate --git https://github.com/zellij-org/rust-plugin-template.git --name mode-logger
cd mode-logger
</code></pre>
<h2 id="the-basic-structure-of-a-rust-plugin"><a class="header" href="#the-basic-structure-of-a-rust-plugin">The Basic Structure of a Rust Plugin</a></h2>
<p>After cloning the template repository, you should have a directory that looks a little bit like this:</p>
<pre><code>.
├── .cargo
│   └── config.toml
├── Cargo.toml
├── plugin.yaml
├── README.md
└── src
    └── main.rs
</code></pre>
<h3 id="cargoconfigtoml"><a class="header" href="#cargoconfigtoml"><code>.cargo/config.toml</code></a></h3>
<pre><code class="language-toml">[build]
target = "wasm32-wasi"
</code></pre>
<p>This file specifies a default target for our project. In this case, the correct WASI target is <code>wasm32-wasi</code>.</p>
<h3 id="cargotoml"><a class="header" href="#cargotoml"><code>Cargo.toml</code></a></h3>
<pre><code class="language-toml">[package]
name = "mode-logger"
version = "0.1.0"
authors = ["Brooks J Rady &lt;b.j.rady@gmail.com&gt;"]
edition = "2018"

[dependencies]
zellij-tile = "1.0.0"
</code></pre>
<p>This is a quite standard package file that <code>cargo-generate</code> has partially filled in for us. Note the dependency on <code>zellij-tile</code> which provides some helpful functionality for avoiding boilerplate and writing <code>unsafe</code> code.</p>
<h3 id="pluginyaml"><a class="header" href="#pluginyaml"><code>plugin.yaml</code></a></h3>
<pre><code class="language-yaml">---
direction: Horizontal
parts:
  - direction: Vertical
    split_size:
      Fixed: 1
    plugin: tab-bar
  - direction: Vertical
    plugin: target/wasm32-wasi/debug/mode-logger.wasm
  - direction: Vertical
    split_size:
      Fixed: 2
    plugin: status-bar
</code></pre>
<p>This is a Zellij <a href="./layouts.html">Layout</a> that loads a mostly default instance of Zellij, but with the middle terminal pane replaced by the plugin being developed. The <code>plugin: target/wasm32-wasi/debug/mode-logger.wasm</code> line should point Zellij to the development version of our plugin.</p>
<p>There will likely be a better way of loading plugins in the future, but custom Layouts are currently the only way to do so.</p>
<h3 id="srcmainrs"><a class="header" href="#srcmainrs"><code>src/main.rs</code></a></h3>
<pre><code class="language-rs">use zellij_tile::prelude::*;

#[derive(Default)]
struct State;

register_plugin!(State);

impl ZellijPlugin for State {
    fn load(&amp;mut self) {}

    fn update(&amp;mut self, event: Event) {}

    fn render(&amp;mut self, rows: usize, cols: usize) {}
}
</code></pre>
<p>When using the <code>zellij-tile</code> library, plugins are written as Structs that implement the <code>ZellijPlugin</code> trait. The magic line here is <code>register_plugin!(State)</code>, which wraps up the <code>State</code> struct in a way that neatly exposes its <code>ZellijPlugin</code> implementation for Zellij to find.</p>
<p>Note that <code>load()</code>, <code>update()</code>, and <code>render()</code> have default implementations, so you only need to define the callbacks used by your plugin.</p>
<h2 id="hello-zellij"><a class="header" href="#hello-zellij">Hello, Zellij!</a></h2>
<p>Let's tweak our <code>main.rs</code> a little to say hello!</p>
<pre><code class="language-rs">use zellij_tile::prelude::*;

#[derive(Default)]
struct State;

register_plugin!(State);

impl ZellijPlugin for State {
    fn load(&amp;mut self) {}

    fn update(&amp;mut self, event: Event) {}

    fn render(&amp;mut self, rows: usize, cols: usize) {
        println!("Hello, Zellij!");
    }
}
</code></pre>
<p>It really is as simple as that! Anything printed to stdout by the <code>render()</code> method will be automatically drawn to the screen in the pane where the plugin is active.</p>
<p>Let's build our plugin and test things out:</p>
<pre><code class="language-sh">cargo build
zellij --layout-path plugin.yaml
</code></pre>
<p><img src="img/rust-plugin-1.png" alt="Our Plugin" /></p>
<h2 id="implementing-the-event-logger"><a class="header" href="#implementing-the-event-logger">Implementing the Event Logger</a></h2>
<p>That was pretty easy, so let's try to do something a bit more interesting! Let's subscribe to some <code>Event</code>s by adding the following code to <code>load()</code>:</p>
<pre><code class="language-rs">fn load(&amp;mut self) {
    subscribe(&amp;[EventType::ModeUpdate]);
}
</code></pre>
<p>Code in <code>load()</code> is called once the first time your plugin is loaded. Aside from that, it's nothing special. Anything that you can do in the <code>load()</code> method should be possible from within the <code>update()</code> and <code>render()</code> methods as well.</p>
<p>The <code>subscribe()</code> function is part of <code>zellij-tile::prelude</code> and sends a message to Zellij asking to be notified when certain <code>Event</code>s occur. In this case, we're subscribing to <code>ModeUpdate</code> events. The <a href="https://docs.rs/zellij-tile/1.0.0/zellij_tile/data/enum.Event.html">documentation for <code>Event</code></a> tells us that a <code>ModeUpdate</code> contains the <code>ModeInfo</code> struct, which stores the current mode as well as some additional information.</p>
<p>To actually handle these events, we'll need to add some code to our <code>update()</code> method:</p>
<pre><code class="language-rs">fn update(&amp;mut self, event: Event) {
    if let Event::ModeUpdate(mode_info) = event {
        dbg!(mode_info.mode);
    }
}
</code></pre>
<p>Here we are checking for <code>ModeUpdate</code>s and destructuring them to get the current mode. Currently, the <code>dbg!()</code> macro is being used to dump this information to stderr. If we want to actually see this debug info, we'll need to run our plugin slightly differently:</p>
<pre><code class="language-sh">cargo build
# The 2&gt; redirects stderr to dbg.log
zellij -l plugin.yaml 2&gt; dbg.log
</code></pre>
<p>Do some faffing about in Zellij, changing modes a couple of times, then take a look at <code>dbg.log</code>:</p>
<pre><code>[src/main.rs:15] mode_info.mode = Normal
[src/main.rs:15] mode_info.mode = Pane
[src/main.rs:15] mode_info.mode = Tab
[src/main.rs:15] mode_info.mode = Resize
[src/main.rs:15] mode_info.mode = Scroll
[src/main.rs:15] mode_info.mode = Locked
[src/main.rs:15] mode_info.mode = Normal
</code></pre>
<p>Excellent! It looks like our plugin is receiving mode updates! If you'd like to see these sorts of logs live, try opening a second terminal and running <code>tail -f dbg.log</code>.</p>
<p>The next thing to do is properly store a log of events and print them to the screen. Let's start by tweaking our <code>State</code> struct:</p>
<pre><code class="language-rs">use std::collections::VecDeque;

#[derive(Default)]
struct State {
    log: VecDeque&lt;String&gt;,
}
</code></pre>
<p>We've gone with a <code>VecDeque</code> so that we can efficiently push <code>String</code>s to the <em>front</em> of <code>log</code> and so we can show off how easy it is to use standard library components from within a plugin.</p>
<p>Let's change the <code>update()</code> method again to grow our log:</p>
<pre><code class="language-rs">fn update(&amp;mut self, event: Event) {
    if let Event::ModeUpdate(mode_info) = event {
        let mode = format!("{:?}", mode_info.mode);
        self.log.push_front(mode);
    }
}
</code></pre>
<p>Recall that the <code>{:?}</code> format specifier simply debug-prints a value and that <code>log.push_front(mode)</code> adds a mode <code>String</code> to the front of our log messages.</p>
<p>Finally, let's update <code>render()</code> to print out all of our log messages:</p>
<pre><code class="language-rs">fn render(&amp;mut self, rows: usize, cols: usize) {
    for mode in &amp;self.log {
        println!("Mode: {}", mode);
    }
}
</code></pre>
<p>Let's give things a run with <code>cargo build &amp;&amp; zellij -l plugin.yaml</code> and test it out!</p>
<p><img src="img/rust-plugin-2.png" alt="Our Plugin" /></p>
<p>Excellent! You should notice that, as you cycle through different modes in Zellij, that those updates are being logged on-screen.</p>
<p>This is a good start, but no logger is complete without storing timestamps! Let's import the <code>chrono</code> crate for working with time. First we'll need to add it to our <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "mode-logger"
version = "0.1.0"
authors = ["Brooks J Rady &lt;b.j.rady@gmail.com&gt;"]
edition = "2018"

[dependencies]
zellij-tile = "1.0.0"
chrono = "0.4"
</code></pre>
<p>Quite a few Rust libraries can compile to WebAssembly without any issue – this is one of them! Let's import it and update <code>State</code> to store timestamps:</p>
<pre><code class="language-rs">use chrono::{DateTime,Local};

#[derive(Default)]
struct State {
    log: VecDeque&lt;(String, DateTime&lt;Local&gt;)&gt;,
}
</code></pre>
<p>Next we'll need to actually store these timestamps in <code>update()</code>:</p>
<pre><code class="language-rs">fn update(&amp;mut self, event: Event) {
    if let Event::ModeUpdate(mode_info) = event {
        let mode = format!("{:?}", mode_info.mode);
        // Local::now() gets the current time and date
        self.log.push_front((mode, Local::now()));
    }
}
</code></pre>
<p>Finally, we can <code>render()</code> the timestamps to the screen:</p>
<pre><code class="language-rs">fn render(&amp;mut self, rows: usize, cols: usize) {
    for (mode, time) in &amp;self.log {
        println!("Mode: {} ({})", mode, time.format("%T"));
    }
}
</code></pre>
<p>The different options for <code>time.format()</code> can be found in the <a href="https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html"><code>chrono::format::strftime</code></a> module; <code>%T</code> shows the time in <code>HH:MM:SS</code> format.</p>
<p>Finally, let's test this out!</p>
<p><img src="img/rust-plugin-3.png" alt="Our Plugin" /></p>
<p>It looks like getting the time is working perfectly! Unfortunately, because our different mode names are different lengths, it looks a bit messy at the moment. Luckily, every time that <code>render()</code> is called, it passes the size of plugin pane. Let's use the <code>cols</code> value to right-align the timestamp:</p>
<pre><code class="language-rs">fn render(&amp;mut self, _rows: usize, cols: usize) {
    for (mode, time) in &amp;self.log {
        let mode = format!("Mode: {}", mode);
        let time = time.format("%T").to_string();
        let padding = " ".repeat(cols - mode.len() - time.len());
        println!("{}{}{}", mode, padding, time);
    }
}
</code></pre>
<p>By separately storing the left-aligned mode <code>String</code> and the right-aligned timestamp, we can calculate (using <code>cols</code>) exactly how much padding we need to fill the screen. Once we've done that, it's just a matter of printing the left half, the padding, then the right half.</p>
<p>If we run this code, we now get the much nicer:</p>
<p><img src="img/rust-plugin-4.png" alt="Our Plugin" /></p>
<p>Try resizing your terminal window or the plugin pane and watch how things stay properly justified!</p>
<p>As a final step, let's add a couple of commands that allow the user to clear their history or save their log to a file. To do this, we'll need our plugin to receive <code>KeyPress</code> events:</p>
<pre><code class="language-rs">fn load(&amp;mut self) {
    subscribe(&amp;[EventType::ModeUpdate, EventType::KeyPress]);
}
</code></pre>
<p>Now we can expand <code>update()</code> to handle <code>ModeUpdate</code> and <code>KeyPress</code> events. Let's make <code>Ctrl-L</code> the command for clearing the logs:</p>
<pre><code class="language-rs">fn update(&amp;mut self, event: Event) {
    match event {
        Event::ModeUpdate(mode_info) =&gt; {
            let mode = format!("{:?}", mode_info.mode);
            self.log.push_front((mode, Local::now()));
        }
        Event::KeyPress(Key::Ctrl('l')) =&gt; self.log.clear(),
        _ =&gt; (),
    }
}
</code></pre>
<p>When matching against <code>KeyPress</code> events, you might find it helpful to explore the <a href="https://docs.rs/zellij-tile/1.0.0/zellij_tile/data/enum.Key.html">zellij_tile::Key</a> enum.</p>
<p>Also note that we need the catch-all case <code>_ =&gt; ()</code> because, even though we've only subscribed to the <code>ModeUpdate</code> and <code>KeyPress</code> events, the Rust compiler on its own can't guarantee that only those events will be passed to <code>update()</code>.</p>
<p>Let's try running this, changing modes a couple of times, then pressing <code>Ctrl-L</code>:</p>
<p><img src="img/rust-plugin-5.png" alt="Our Plugin" /></p>
<p>Incredibly blank! Nicely done!</p>
<p>As one final feature, we'll dump a log of the captured events to <code>mode-log.txt</code> when <code>Ctrl-W</code> is pressed:</p>
<pre><code class="language-rs">use std::{fs::File, io::Write};

// ... snip ...

fn update(&amp;mut self, event: Event) {
    match event {
        Event::ModeUpdate(mode_info) =&gt; {
            let mode = format!("{:?}", mode_info.mode);
            self.log.push_front((mode, Local::now()));
        }
        Event::KeyPress(Key::Ctrl('l')) =&gt; self.log.clear(),
        Event::KeyPress(Key::Ctrl('w')) =&gt; {
            if let Ok(mut f) = File::create("mode-log.txt") {
                for (mode, time) in self.log.iter().rev() {
                    writeln!(f, "{}: Entered {} Mode", time.format("%c"), mode).unwrap();
                }
            }
        }
        _ =&gt; (),
    }
}
</code></pre>
<p>A couple of new things here, but all of them are vanilla Rust – nothing changes when writing a plugin! <code>File::create("mode-log.txt")</code> is just normal code for creating a file named <code>mode-log.txt</code> in the current directory. After the file is created, we're again looping through all of the log events and writing them out (but this time to a file!). The format of the log file is also a bit different from the log we show on-screen. First of all, we're writing things to the log file in <em>chronological</em> order (that's why we're reversing our log with <code>self.log.iter().rev()</code>), and we've also changed to a more verbose timestamp. The <code>%c</code> should look something like this: <code>Tue Apr 20 10:21:02 2021</code>.</p>
<p>Let's run Zellij again, change some modes, then press <code>Ctrl-W</code>:</p>
<p><img src="img/rust-plugin-6.png" alt="Our Plugin" /></p>
<p>We can then look at <code>mode-log.txt</code>, which should look something like this:</p>
<pre><code>Tue Apr 20 10:20:40 2021: Entered Normal Mode
Tue Apr 20 10:20:46 2021: Entered Pane Mode
Tue Apr 20 10:20:50 2021: Entered Tab Mode
Tue Apr 20 10:20:53 2021: Entered Resize Mode
Tue Apr 20 10:20:57 2021: Entered Scroll Mode
Tue Apr 20 10:21:00 2021: Entered Locked Mode
Tue Apr 20 10:21:02 2021: Entered Normal Mode
</code></pre>
<p>And that's all, folks! The full code for this example can be found in the <a href="https://github.com/zellij-org/rust-plugin-example/blob/main/src/main.rs"><code>rust-plugin-example</code></a> repository.</p>
<h2 id="further-steps"><a class="header" href="#further-steps">Further Steps</a></h2>
<p>There are a <em>lot</em> of ways that this plugin could be improved! Here are a couple of the things that you might want to try implementing if you're looking for the extra practice:</p>
<ul>
<li><strong>Support for scrolling ::</strong> you'll need to use <code>rows</code> and save a cursor position in <code>State</code></li>
<li><strong>Make it pretty ::</strong> our default plugins use the <a href="https://crates.io/crates/colored"><code>colored</code></a> crate for fancy formatting</li>
<li><strong>Make it more stable ::</strong> if you make the logger pane too small, the plugin will crash!</li>
<li><strong>Add a help bar ::</strong> there is currently no UI telling the user about the clear and save features</li>
</ul>
<p>Have fun, and don't hesitate to get in touch if you find any bugs or would like some guidance :)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="plugin-writing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="plugin-zig.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="plugin-writing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="plugin-zig.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
